# -*- coding: utf-8 -*-
"""DataLoader.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FG0PHFW_d_QU3rOFgx-TxoSl7HoXLgfp

# Preamble
"""

import numpy as np
import rasterio
from typing import Sequence, Optional, Callable, Any
from torch.utils.data import Dataset, DataLoader
import os
from sklearn.model_selection import KFold
from torchvision.transforms import ToTensor
import glob
import rasterio
import json
from tqdm import tqdm
from skimage import io
import re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from rasterio.plot import show,show_hist
import random

jsonpath2 = '/content/drive/MyDrive/CropClassification/Data/Train/train_source_s2/ref_south_africa_crops_competition_v1_train_source_s2/collection.json'
labeljsonpath2 = '/content/drive/MyDrive/CropClassification/Data/Train/train_labels/ref_south_africa_crops_competition_v1_train_labels/collection.json'

s2_json = '/content/drive/MyDrive/CropClassification/DataRestructured/Train/train_source_s2/ref_south_africa_crops_competition_v1_train_source_s2/collection.json'
labels_json = '/content/drive/MyDrive/CropClassification/DataRestructured/Train/train_labels/ref_south_africa_crops_competition_v1_train_labels/collection.json'

bands_curr2=['B01','B02','B03','B04','B05','B06','B07','B08','B8A','B09','B11','B12','labels','field_ids']

"""# Band helper functions"""

def proportion_cloud(path_picture):
    with rasterio.open(path_picture) as i:
      img = i.read()
    prop_cloud = img.sum()/(256*256*255)  
    return(prop_cloud)

"""# Create bands dictionary"""

def get_Dict_data(path_to_collection,req_bands, size_subsample, max_prop_clm, check_clouds=False):
    #Args
    #> path to collection.Json
    #> which bands? - List of strings e.g. ['B02']
    #> subsample size - int < total pictures
    #> maximum proportion of clouded area in picture - float 0.-1.    
    
    ### open JSON
    
    # path to collection.JSON
    path_collection_Json = path_to_collection
    
    # open collection.JSON
    with open(path_collection_Json) as json_file_paths:
        alldat_Json = json.load(json_file_paths)
    
    # test data path  
    fold_path = path_collection_Json[0:-16]
    
    # list of individual stack.JSON/ select subset
    spec_dat = [fold_path + '/' + i['href'] for i in alldat_Json['links'][0:size_subsample]]
    
    ### get collection of individuals band links and put into list/dict
    dict_of_dict = {}
    l_of_dict = []
    
    ## for each folder
    for link in tqdm(spec_dat):
        #check if folder exists, elso do none
        try:
            # if exist, open individual stack.JSON
            with open(link) as json_file_paths_stack:
                curr_folder = json.load(json_file_paths_stack)['assets']
                
                # collect/generate links to specific band .tiff files
                band_path = {}
                for indx_D in curr_folder.keys():
                    band_path[indx_D] = link[0:-9] + curr_folder[indx_D]['href']
                
                # check cloud cover
                if check_clouds:
                  prop_clm = proportion_cloud(band_path['CLM'])
                  if (prop_clm <max_prop_clm): 
                    l_of_dict.append(band_path)
                  else:
                    None
                else:
                  l_of_dict.append(band_path)

    
                ## dict with unique location values 
                # date not considered !!!
                item = link.split('_')[-4]
                dict_of_dict[item] = curr_folder
        except:
            None
    
    dict_out = {}
    
    for band in req_bands:
        curr_band = [i[band] for i in l_of_dict]
        dict_out[band] = curr_band
    
    return dict_out


"""# Create bands + label dictionary"""

def get_file_list(data_json, label_json, req_bands, size_subsample, max_prop_clm, check_clouds=False, choice_fn=random.choice):# path_to_collection,req_bands, size_subsample, max_prop_clm, check_clouds=False):
    #Args
    #> path to collection.Json
    #> which bands? - List of strings e.g. ['B02']
    #> subsample size - int < total pictures
    #> maximum proportion of clouded area in picture - float 0.-1.    
    
    ### open JSON  

    # open collection.JSON
    with open(data_json) as json_file_paths:
        alldat_Json = json.load(json_file_paths)
    with open(label_json) as json_file_paths:
      labeldat_Json = json.load(json_file_paths)

    # data path  
    data_dir = os.path.dirname(data_json)#data_json[0:-16]
    label_dir = os.path.dirname(label_json)

    # list of individual stack.JSON/ select subset
    all_data_paths = [os.path.join(data_dir, line['href']) for line in alldat_Json['links']]
    all_label_paths = [os.path.join(label_dir, line['href']) for line in labeldat_Json['links']]

    # make a list of codenames for each stac-path.
    label_codes = [codename(path, 'label') for path in all_label_paths]
    s2_codes = [codename(path,'s2') for path in all_data_paths]

    # find those codes which are the same between the two lists
    common_codes = list(set(s2_codes).intersection(label_codes))
    common_codes = common_codes[:size_subsample]

    # save all the paths to a dict indexed by the code.
    json_paths = {}
    for code in common_codes:
      found_labels = all_label_paths[label_codes.index(code)]
      found_s2 = [all_data_paths[idx] for idx, scode in enumerate(s2_codes) if scode == code]
      json_paths[code] = {'label': found_labels, 's2': found_s2}

    # get collection of individuals band links and put into list/dict
    dict_of_dict = {}
    l_of_dict = []

    ## for each folder
    for code in tqdm(json_paths.keys()):#zip(label_json_paths, s2_json_paths),total=len(s2_json_paths)):
        
      label = json_paths[code]['label']
      dat = choice_fn(json_paths[code]['s2'])
      
      # save the satelite tif paths
      with open(dat) as json_file_paths_stack:
        curr_folder = json.load(json_file_paths_stack)['assets']
      
      # collect/generate links to specific band .tiff files
      band_path = {}
      for indx_D in curr_folder.keys():
          band_path[indx_D] = dat[0:-9] + curr_folder[indx_D]['href']
      
      ## dict with unique location values 
      # date not considered !!!
      #item = link.split('_')[-4]
      #dict_of_dict[item] = curr_folder

      # save the label paths
      with open(label) as json_label_paths_stack:
        curr_folder = json.load(json_label_paths_stack)['assets']

      # collect/generate links to specific band .tiff files
      for indx_D in curr_folder.keys():
          band_path[indx_D] = os.path.join(os.path.dirname(label), curr_folder[indx_D]['href'])

      # check the cloud cover.
      if check_clouds:
        prop_clm = proportion_cloud(band_path['CLM'])
        if (prop_clm <max_prop_clm): 
          l_of_dict.append(band_path)
        else:
          None
      else:
        l_of_dict.append(band_path)

    dict_out = {}
    for band in req_bands:
        curr_band = [i[band] for i in l_of_dict]
        dict_out[band] = curr_band

    return dict_out


class Dataset_multiS2_T1(Dataset):#, Randomizable):
    def __init__(self, data_dict, im_transform, lbl_transform):
      self.label_file_list=data_dict['labels']
      self.s2_file_list=[data_dict[i] for i in data_dict.keys() if i not in ['labels','field_ids'] ]
      self.loader = rasterio.open
      self._seed = 0  # transform synchronization seed
      self.image_transform = im_transform
      self.label_transform = lbl_transform

    def __len__(self):
      return len(self.s2_file_list[0])
      # return len(self.label_directories) if we want just the number of areas mapped

    def randomize(self, data = None):
      self._seed = 2021 #self.R.randint(np.iinfo(np.int32).max)

    def make_label_images(self, img, n_classes):
      img = img.read().squeeze()
      img_shape = img.shape
      label_images = np.zeros(img_shape + (n_classes,))

      # find the labels in the input image
      vals = np.arange(n_classes)

      for i in vals:
        label_idx = np.where(img==i)
        label_images[label_idx[0], label_idx[1], i] = 1

      return label_images

    def make_image_images(self, file_list, index):
      image_images = np.zeros(self.loader(file_list[0][0]).read().squeeze().shape + (len(file_list),))

      for i in np.arange(len(file_list)):
        image_images[:,:,i] = self.loader(file_list[i][index]).read().squeeze()

      return image_images

    def __getitem__(self, index):
      self.randomize()
      #print(index)
      img_images = self.make_image_images(self.s2_file_list, index)
      

      lbl = self.loader(self.label_file_list[index])
      lbl_images = self.make_label_images(lbl, 10)
      #print(lbl_images.shape)
      return self.image_transform(img_images), self.label_transform(lbl_images)


def generate_splits(data_dict, split_ratios, shuffle=False):
  bands = list(data_dict.keys())
  kf = KFold(n_splits=split_ratios, shuffle=shuffle)
  train_files = list()
  test_files = list()
  
  for train_idx, test_idx in kf.split(range(len(data_dict[bands[0]]))):
    train_current_ims = {}
    test_current_ims = {}
    for band in bands:
      train_current_ims[band] = list()
      test_current_ims[band] = list()

    [[train_current_ims[key].append(data_dict[key][idx]) for idx in train_idx] for key in bands]
    train_files.append(train_current_ims)
    [[test_current_ims[key].append(data_dict[key][idx]) for idx in test_idx] for key in bands]
    test_files.append(test_current_ims)

  return train_files, test_files


def codename(filepath, pathtype='label'):
  if pathtype == 'label':
    code_position = -1
  elif pathtype == 's2':
    code_position = -4
  else:
    raise ValueError('don''t know that pathytpe, should be label or s2')
  return os.path.basename(os.path.dirname(filepath)).split('_')[code_position]

def choose_clearest_day(paths_to_stacs):
  cloud_coverage = np.zeros(len(paths_to_stacs))
  for i, stacpath in enumerate(paths_to_stacs):
    with open(stacpath, 'r') as f:
      meta_data = json.load(f)
    clm_path = metadata['CLM']['href']
    cloud_coverage[i] = proportion_cloud(clm_path)
  return paths_to_stacs[np.argmin(np.array(cloud_coverage))]